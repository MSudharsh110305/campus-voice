import firebase_admin
from firebase_admin import credentials, firestore
from datetime import datetime, timezone
from typing import Dict, Any, Optional, List, Tuple
import uuid
import time

from api.models import (
    QueuedComplaint, ProcessedComplaint, PublicComplaint, 
    ComplaintVote, ComplaintSubmission
)

class FirebaseService:
    """Complete Firebase service for Campus Grievance Portal"""
    
    def __init__(self, credentials_path: str = 'firebase-key.json'):
        # Initialize Firebase Admin SDK
        if not firebase_admin._apps:
            try:
                cred = credentials.Certificate(credentials_path)
                firebase_admin.initialize_app(cred)
                print("🔥 Firebase initialized successfully")
            except Exception as e:
                print(f"❌ Firebase initialization failed: {e}")
                raise
        
        self.db = firestore.client()
        
        # Collection names
        self.QUEUED_COMPLAINTS = 'queued_complaints'
        self.PROCESSED_COMPLAINTS = 'processed_complaints'
        self.PUBLIC_COMPLAINTS = 'public_complaints'
        self.PRIVATE_COMPLAINTS = 'private_complaints'
        self.COMPLAINT_VOTES = 'complaint_votes'
        
        print("📊 Firebase collections initialized")
    
    # =================== QUEUE OPERATIONS ===================
    
    def submit_complaint(self, submission: ComplaintSubmission) -> Tuple[str, int]:
        """Submit complaint to queue and return complaint_id and queue position"""
        try:
            # Generate unique complaint ID
            complaint_id = f"complaint_{int(time.time() * 1000)}_{str(uuid.uuid4())[:8]}"
            
            # Create queued complaint
            queued_complaint = QueuedComplaint(
                complaint_id=complaint_id,
                complaint_text=submission.complaint_text,
                user_department=submission.user_department,
                user_residence=submission.user_residence,
                user_email=submission.user_email,
                user_phone=submission.user_phone,
                image_data=submission.image_data,
                image_description=None,  # Will be generated by LLM if image exists
                visibility=submission.visibility,
                created_at=datetime.now(timezone.utc),
                status='pending'
            )
            
            # Add to Firebase queue
            doc_ref = self.db.collection(self.QUEUED_COMPLAINTS).document(complaint_id)
            doc_ref.set(queued_complaint.to_dict())
            
            # Get queue position
            queue_position = self._get_queue_position()
            
            # Update queue position
            doc_ref.update({'queue_position': queue_position})
            
            print(f"📝 Complaint queued: {complaint_id} (position: {queue_position})")
            return complaint_id, queue_position
            
        except Exception as e:
            print(f"❌ Failed to submit complaint: {e}")
            raise
    
    def get_next_queued_complaint(self) -> Optional[QueuedComplaint]:
        """Get next complaint from queue for processing"""
        try:
            # Get oldest pending complaint
            docs = list(
                self.db.collection(self.QUEUED_COMPLAINTS)
                .where('status', '==', 'pending')
                .limit(1)
                .stream()
            )
            
            if not docs:
                return None
            
            doc = docs[0]
            data = doc.to_dict()
            
            # Mark as processing
            doc.reference.update({
                'status': 'processing',
                'processing_started_at': datetime.now(timezone.utc)
            })
            
            # Convert to model
            queued_complaint = QueuedComplaint(
                complaint_id=data['complaint_id'],
                complaint_text=data['complaint_text'],
                user_department=data['user_department'],
                user_residence=data.get('user_residence'),
                user_email=data.get('user_email'),
                user_phone=data.get('user_phone'),
                image_data=data.get('image_data'),
                image_description=data.get('image_description'),
                visibility=data['visibility'],
                created_at=datetime.fromisoformat(data['created_at'].replace('Z', '+00:00')),
                status=data['status'],
                queue_position=data.get('queue_position', 0)
            )
            
            print(f"🔄 Retrieved queued complaint: {queued_complaint.complaint_id}")
            return queued_complaint
            
        except Exception as e:
            print(f"❌ Failed to get queued complaint: {e}")
            return None
    
    def _get_queue_position(self) -> int:
        """Calculate current queue position"""
        try:
            count = len(list(
                self.db.collection(self.QUEUED_COMPLAINTS)
                .where('status', '==', 'pending')
                .stream()
            ))
            return count + 1
        except:
            return 1
    
    # =================== PROCESSING OPERATIONS ===================
    
    def save_processed_complaint(self, processed: ProcessedComplaint) -> bool:
        """Save processed complaint to appropriate subcollection"""
        try:
            # Determine subcollection based on classification
            if processed.classification == 'academic':
                # Use department as subcollection for academic complaints
                dept_name = processed.subcategory or processed.user_department.replace(' ', '_').lower()
                collection_path = f"{self.PROCESSED_COMPLAINTS}/academic/{dept_name}"
            elif processed.classification == 'hostel':
                collection_path = f"{self.PROCESSED_COMPLAINTS}/hostel/complaints"
            elif processed.classification == 'infrastructure':
                collection_path = f"{self.PROCESSED_COMPLAINTS}/infrastructure/complaints"
            else:
                # Fallback to infrastructure
                collection_path = f"{self.PROCESSED_COMPLAINTS}/infrastructure/complaints"
            
            # Save to appropriate subcollection
            doc_ref = self.db.collection(collection_path).document(processed.complaint_id)
            doc_ref.set(processed.to_dict())
            
            # Handle visibility-based storage
            if processed.visibility == 'public':
                self._save_to_public_complaints(processed)
            else:
                self._save_to_private_complaints(processed)
            
            # Remove from queue
            self._remove_from_queue(processed.complaint_id)
            
            print(f"✅ Processed complaint saved: {processed.complaint_id} -> {collection_path}")
            return True
            
        except Exception as e:
            print(f"❌ Failed to save processed complaint: {e}")
            return False
    
    def _save_to_public_complaints(self, processed: ProcessedComplaint):
        """Save public complaint for voting"""
        try:
            public_complaint = PublicComplaint(
                complaint_id=processed.complaint_id,
                rephrased_complaint=processed.rephrased_complaint,
                classification=processed.classification,
                final_authority=processed.final_authority,
                priority_level=processed.priority_level,
                department=processed.user_department,
                created_at=processed.created_at
            )
            
            self.db.collection(self.PUBLIC_COMPLAINTS).document(processed.complaint_id).set(
                public_complaint.to_dict()
            )
            
            print(f"🔓 Public complaint saved for voting: {processed.complaint_id}")
            
        except Exception as e:
            print(f"❌ Failed to save public complaint: {e}")
    
    def _save_to_private_complaints(self, processed: ProcessedComplaint):
        """Save private/confidential complaint"""
        try:
            private_data = {
                'complaint_id': processed.complaint_id,
                'original_complaint': processed.original_complaint,
                'rephrased_complaint': processed.rephrased_complaint,
                'classification': processed.classification,
                'final_authority': processed.final_authority,
                'user_email': processed.user_email,
                'created_at': processed.created_at.isoformat(),
                'visibility': processed.visibility
            }
            
            self.db.collection(self.PRIVATE_COMPLAINTS).document(processed.complaint_id).set(
                private_data
            )
            
            print(f"🔒 Private complaint saved: {processed.complaint_id}")
            
        except Exception as e:
            print(f"❌ Failed to save private complaint: {e}")
    
    def _remove_from_queue(self, complaint_id: str):
        """Remove complaint from processing queue"""
        try:
            self.db.collection(self.QUEUED_COMPLAINTS).document(complaint_id).update({
                'status': 'completed',
                'completed_at': datetime.now(timezone.utc)
            })
        except Exception as e:
            print(f"❌ Failed to remove from queue: {e}")
    
    # =================== RETRIEVAL OPERATIONS ===================
    
    def get_complaint_status(self, complaint_id: str) -> Optional[Dict[str, Any]]:
        """Get complaint status from any collection"""
        try:
            # Check if in queue
            queue_doc = self.db.collection(self.QUEUED_COMPLAINTS).document(complaint_id).get()
            if queue_doc.exists:
                data = queue_doc.to_dict()
                data['location'] = 'queue'
                return data
            
            # Check processed complaints (all subcollections)
            collections_to_check = [
                f"{self.PROCESSED_COMPLAINTS}/academic/computer_science_engineering",
                f"{self.PROCESSED_COMPLAINTS}/academic/electronics_communication_engineering",
                f"{self.PROCESSED_COMPLAINTS}/hostel/complaints",
                f"{self.PROCESSED_COMPLAINTS}/infrastructure/complaints"
            ]
            
            for collection_path in collections_to_check:
                try:
                    doc = self.db.collection(collection_path).document(complaint_id).get()
                    if doc.exists:
                        data = doc.to_dict()
                        data['location'] = collection_path
                        return data
                except:
                    continue
            
            # Check public complaints
            public_doc = self.db.collection(self.PUBLIC_COMPLAINTS).document(complaint_id).get()
            if public_doc.exists:
                data = public_doc.to_dict()
                data['location'] = 'public'
                return data
            
            # Check private complaints
            private_doc = self.db.collection(self.PRIVATE_COMPLAINTS).document(complaint_id).get()
            if private_doc.exists:
                data = private_doc.to_dict()
                data['location'] = 'private'
                return data
            
            return None
            
        except Exception as e:
            print(f"❌ Failed to get complaint status: {e}")
            return None
    
    def get_public_complaints(self, category: Optional[str] = None, limit: int = 50) -> List[Dict[str, Any]]:
        """Get public complaints for voting"""
        try:
            query = self.db.collection(self.PUBLIC_COMPLAINTS).limit(limit)
            
            if category:
                query = query.where('classification', '==', category)
            
            complaints = []
            for doc in query.stream():
                data = doc.to_dict()
                complaints.append(data)
            
            # Sort by creation time (most recent first)
            complaints.sort(key=lambda x: x.get('created_at', ''), reverse=True)
            return complaints
            
        except Exception as e:
            print(f"❌ Failed to get public complaints: {e}")
            return []
    
    def get_complaints_by_category(self, category: str, department: Optional[str] = None) -> List[Dict[str, Any]]:
        """Get complaints by category and optionally by department"""
        try:
            complaints = []
            
            if category == 'academic' and department:
                dept_path = department.replace(' ', '_').lower()
                collection_path = f"{self.PROCESSED_COMPLAINTS}/academic/{dept_path}"
            elif category == 'hostel':
                collection_path = f"{self.PROCESSED_COMPLAINTS}/hostel/complaints"
            elif category == 'infrastructure':
                collection_path = f"{self.PROCESSED_COMPLAINTS}/infrastructure/complaints"
            else:
                return []
            
            docs = self.db.collection(collection_path).limit(100).stream()
            for doc in docs:
                data = doc.to_dict()
                complaints.append(data)
            
            return complaints
            
        except Exception as e:
            print(f"❌ Failed to get complaints by category: {e}")
            return []
    
    # =================== VOTING OPERATIONS ===================
    
    def vote_complaint(self, complaint_id: str, user_id: str, vote_type: str) -> Dict[str, Any]:
        """Handle voting on public complaints"""
        try:
            # Check if complaint is public
            public_doc = self.db.collection(self.PUBLIC_COMPLAINTS).document(complaint_id).get()
            if not public_doc.exists:
                return {'success': False, 'message': 'Complaint not found or not public'}
            
            # Check existing vote
            vote_id = f"{complaint_id}_{user_id}"
            vote_doc = self.db.collection(self.COMPLAINT_VOTES).document(vote_id).get()
            
            if vote_doc.exists:
                old_vote = vote_doc.to_dict()['vote_type']
                if old_vote == vote_type:
                    return {'success': False, 'message': 'Already voted'}
                
                # Update existing vote
                vote_doc.reference.update({
                    'vote_type': vote_type,
                    'updated_at': datetime.now(timezone.utc)
                })
                
                # Update complaint counts
                if old_vote == 'upvote' and vote_type == 'downvote':
                    public_doc.reference.update({
                        'upvotes': firestore.Increment(-1),
                        'downvotes': firestore.Increment(1)
                    })
                elif old_vote == 'downvote' and vote_type == 'upvote':
                    public_doc.reference.update({
                        'upvotes': firestore.Increment(1),
                        'downvotes': firestore.Increment(-1)
                    })
            else:
                # New vote
                vote = ComplaintVote(
                    complaint_id=complaint_id,
                    user_id=user_id,
                    vote_type=vote_type,
                    created_at=datetime.now(timezone.utc)
                )
                
                self.db.collection(self.COMPLAINT_VOTES).document(vote_id).set(vote.to_dict())
                
                # Update complaint counts
                if vote_type == 'upvote':
                    public_doc.reference.update({'upvotes': firestore.Increment(1)})
                else:
                    public_doc.reference.update({'downvotes': firestore.Increment(1)})
            
            return {'success': True, 'message': 'Vote recorded successfully'}
            
        except Exception as e:
            print(f"❌ Failed to record vote: {e}")
            return {'success': False, 'message': f'Error: {str(e)}'}
    
    # =================== STATISTICS ===================
    
    def get_queue_stats(self) -> Dict[str, Any]:
        """Get queue and system statistics"""
        try:
            # Queue stats
            pending_count = len(list(
                self.db.collection(self.QUEUED_COMPLAINTS)
                .where('status', '==', 'pending')
                .stream()
            ))
            
            processing_count = len(list(
                self.db.collection(self.QUEUED_COMPLAINTS)
                .where('status', '==', 'processing')
                .stream()
            ))
            
            # Public complaints count
            public_count = len(list(self.db.collection(self.PUBLIC_COMPLAINTS).stream()))
            
            # Private complaints count
            private_count = len(list(self.db.collection(self.PRIVATE_COMPLAINTS).stream()))
            
            return {
                'queue': {
                    'pending': pending_count,
                    'processing': processing_count,
                    'total_in_queue': pending_count + processing_count
                },
                'complaints': {
                    'public': public_count,
                    'private': private_count,
                    'total_processed': public_count + private_count
                },
                'system': {
                    'status': 'healthy',
                    'collections_active': 5
                }
            }
            
        except Exception as e:
            print(f"❌ Failed to get statistics: {e}")
            return {'error': str(e)}
